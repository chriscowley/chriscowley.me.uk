<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: virtualisation | Just Another Linux Blog]]></title>
  <link href="http://www.chriscowley.me.uk/blog/categories/virtualisation/atom.xml" rel="self"/>
  <link href="http://www.chriscowley.me.uk/"/>
  <updated>2014-04-14T22:35:19+02:00</updated>
  <id>http://www.chriscowley.me.uk/</id>
  <author>
    <name><![CDATA[Chris Cowley]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Open Source Virtual SAN thought experiment]]></title>
    <link href="http://www.chriscowley.me.uk/blog/2013/09/05/open-source-virtual-san-thought-experiment/"/>
    <updated>2013-09-05T21:19:00+02:00</updated>
    <id>http://www.chriscowley.me.uk/blog/2013/09/05/open-source-virtual-san-thought-experiment</id>
    <content type="html"><![CDATA[<p>Okay, I know I am little slow on the uptake here, but I was on holiday at the time. The announcement of <a href="https://www.vmware.com/products/virtual-san/">Virtual SAN</a> at VMWorld the last week got me thinking a bit.</p>

<!-- more -->


<p>Very briefly, Virtual SAN takes locally attached storage on you hypervisors. It then turns it into a distributed object storage system which you can use to store your VMDKs. <a href="http://www.yellow-bricks.com/2013/09/05/how-do-you-know-where-an-object-is-located-with-virtual-san/">Plenty</a> <a href="http://www.computerweekly.com/news/2240166057/VMware-Virtual-SAN-vision-to-disrupt-storage-paradigm">of</a> <a href="http://chucksblog.emc.com/chucks_blog/2013/08/considering-vsan.html">other</a> <a href="http://architecting.it/2013/08/29/reflections-on-vmworld-2013/">people</a> have gone into a lot more detail. Unlike other systems that did a similar job previously this is not a Virtual Appliance, but runs on the hypervisors themselves.</p>

<p>The technology to do this sort of thing using purely Open Source exists. All this has added is a distributed storage layer on each hypervisor. There are plenty of these exist for Linux, with my preference probably being for GlusterFS. Something like this is what I would have in mind:</p>

<p><img class="center" src="http://i.imgur.com/NHYdf78.png"></p>

<p>Ceph is probably the closest to Virtual SAN, as it is fundamentally object-based. Yes there would be CPU and RAM overhead, but that also exists for Virtual SAN too. Something like DRBD/GFS2 is not really suitable here, because it will not scale-out as much. You would not have to have local storage in all your hypervisor nodes (as with Virtual SAN) too.</p>

<p>I honestly do not see any real problems with this.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VMware CLI installation woes on Centos 6]]></title>
    <link href="http://www.chriscowley.me.uk/blog/2012/02/06/vmware-cli-installation-woes-on-centos-6/"/>
    <updated>2012-02-06T13:09:00+01:00</updated>
    <id>http://www.chriscowley.me.uk/blog/2012/02/06/vmware-cli-installation-woes-on-centos-6</id>
    <content type="html"><![CDATA[<p>Installing the VMware CLI should have been simple, but it was a bit of a fiddle.</p>

<p>Use yum  all the bits it needs:</p>

<!-- more -->


<p><code>
yum install make autoconf automake openssl-devel gcc gcc-c++ make uuid-perl libuuid-devel uuid-devel  perl-Data-Dump perl-SOAP-Lite perl-XML-SAX perl-XML-NamespaceSupport perl-XML-LibXML perl-XML-LibXML-Common perl-CPAN
</code></p>

<p>You should now be able to run the installer, but I had another problem though. The installer script would not believe me that I had a direct internet connection and insisted that I gave some proxy server settings. As a simple workaround I just commented out that code in the installation script:
```
if ( direct_command("env | grep -i http_proxy") ) {
 $httpproxy = 1;
} else {
 print wrap("http_proxy not set. please set environment variable 'http_proxy' e.g. export http_proxy=http://myproxy.mydomain.com:0000 . \n\n", 0);
}
if ( direct_command("env | grep -i ftp_proxy") ) {
 $ftpproxy = 1;
} else {
 print wrap("ftp_proxy not set. please set environment variable 'ftp_proxy' e.g. export ftp_proxy=http://myproxy.mydomain.com:0000 . \n\n", 0);
}</p>

<p>if ( !( $ftpproxy &amp;&amp; $httpproxy)) {</p>

<pre><code>uninstall_file($gInstallerMainDB);
exit 1;
</code></pre>

<p>}
```
After this I was able to run the installer with no problems. Of course, there is still the problem I have VMware about them putting their files under <em>/usr</em>. If it is not under control of my package manager, the default should be <em>/opt</em> or <em>/usr/local</em>.</p>
]]></content>
  </entry>
  
</feed>
